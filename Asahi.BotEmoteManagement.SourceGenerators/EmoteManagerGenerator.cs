using System.CodeDom.Compiler;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Asahi.BotEmoteManagement.SourceGenerators;

[Generator]
public class EmoteManagerGenerator : IIncrementalGenerator
{
    private const string BotEmoteManagementNamespace = "Asahi.BotEmoteManagement";
    private const string AttributeName = $"{BotEmoteManagementNamespace}.GenerateEmoteManagerAttribute";
    private const string EmoteSpecificationInterfaceName = "IEmoteSpecification";
    private const string EmoteSpecificationInterfaceDisplayName = $"{BotEmoteManagementNamespace}.{EmoteSpecificationInterfaceName}";
    private const string EmoteResolverQualifiedName = $"global::{BotEmoteManagementNamespace}.IEmoteResolver";
    private const string EmoteInterfaceQualifiedName = $"global::Discord.IEmote";
    private const string GeneratedCodeAttribute =
        $"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Asahi.BotEmoteManagement.SourceGenerators.{nameof(EmoteManagerGenerator)}\", \"0.0.0.0\")]";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classDeclarations = context.SyntaxProvider
            .ForAttributeWithMetadataName(AttributeName,
                predicate: (node, _) =>
                    node is ClassDeclarationSyntax syntax && syntax.Modifiers.Any(SyntaxKind.PartialKeyword),
                transform: static (ctx, token) => GetNeededManagerInfo(ctx, token))
            .Where(static m => m is not null)
            .Select(static (m, _) => m!.Value);

        context.RegisterSourceOutput(classDeclarations, Execute);
    }

    private static void Execute(SourceProductionContext context, EmoteManagerInfo emoteManagerInfo)
    {
        var result = GenerateCode(emoteManagerInfo);
        
        
        context.AddSource($"{nameof(EmoteManagerGenerator)}.{emoteManagerInfo.Namespace}.{emoteManagerInfo.EmoteManagerClassName}.g.cs", SourceText.From(result, Encoding.UTF8));
    }
    
    private static string GenerateCode(EmoteManagerInfo emoteManagerInfo)
    {
        const string emotesModelPropertyName = "EmotesModel";
        
        using var textWriter = new StringWriter();
        using var sourceBuilder = new IndentedTextWriter(textWriter);

        sourceBuilder.WriteLine("// <auto-generated/>");
        sourceBuilder.WriteLine($"namespace {emoteManagerInfo.Namespace};");
        sourceBuilder.WriteLine();
        sourceBuilder.WriteLine(GeneratedCodeAttribute);
        sourceBuilder.WriteLine($"public partial class {emoteManagerInfo.EmoteManagerClassName}({EmoteResolverQualifiedName} emoteResolver)");
        sourceBuilder.WriteLine("{");
        sourceBuilder.Indent++;
        sourceBuilder.WriteLine("#region Emotes model aliases");
        sourceBuilder.WriteLine();
        foreach (var member in emoteManagerInfo.EmoteSpecMembers)
        {
            sourceBuilder.WriteLine($"public {EmoteInterfaceQualifiedName} {member} => {emotesModelPropertyName}.{member};");
        }
        sourceBuilder.WriteLine();
        sourceBuilder.WriteLine("#endregion");
        sourceBuilder.WriteLine();
        sourceBuilder.WriteLine($"private {emoteManagerInfo.EmoteModelClassNameToGenerate} emotes;");
        sourceBuilder.WriteLine($"public {emoteManagerInfo.EmoteModelClassNameToGenerate} {emotesModelPropertyName} => emotes ??");
        sourceBuilder.Indent++;
        sourceBuilder.WriteLine("throw new System.InvalidOperationException(\"InitializeAsync has not been called yet.\");");
        sourceBuilder.Indent--;
        sourceBuilder.WriteLine();
        sourceBuilder.WriteLine("public async global::System.Threading.Tasks.Task InitializeAsync(");
        sourceBuilder.Indent++;
        sourceBuilder.WriteLine($"{emoteManagerInfo.EmoteSpecQualifiedName} emoteSpecification,");
        sourceBuilder.WriteLine("global::System.Collections.Generic.IList<");
        sourceBuilder.WriteLine($"global::{BotEmoteManagementNamespace}.InternalCustomEmoteTracking> internalEmoteTracking)");
        sourceBuilder.Indent--;
        sourceBuilder.WriteLine("{");
        sourceBuilder.Indent++;
        sourceBuilder.WriteLine($"var mappings = new global::System.Collections.Generic.List<{EmoteResolverQualifiedName}.EmoteSpecMapping>()");
        sourceBuilder.WriteLine("{");
        sourceBuilder.Indent++;
        foreach (var member in emoteManagerInfo.EmoteSpecMembers)
        {
            sourceBuilder.WriteLine($"new(\"{member}\", emoteSpecification.{member}),");
        }
        sourceBuilder.Indent--;
        sourceBuilder.WriteLine("};");
        sourceBuilder.WriteLine();
        sourceBuilder.WriteLine("var resolvedEmotes = await emoteResolver.ResolveAsync(mappings, internalEmoteTracking);");
        sourceBuilder.WriteLine();
        sourceBuilder.WriteLine($"emotes = new {emoteManagerInfo.EmoteModelClassNameToGenerate}()");
        sourceBuilder.WriteLine("{");
        sourceBuilder.Indent++;
        foreach (var member in emoteManagerInfo.EmoteSpecMembers)
        {
            sourceBuilder.WriteLine($"{member} = resolvedEmotes[\"{member}\"],");
        }
        sourceBuilder.Indent--;
        sourceBuilder.WriteLine("};");
        sourceBuilder.Indent--;
        sourceBuilder.WriteLine("}");
        sourceBuilder.WriteLine();
        sourceBuilder.WriteLine(GeneratedCodeAttribute);
        sourceBuilder.WriteLine($"public record {emoteManagerInfo.EmoteModelClassNameToGenerate}");
        sourceBuilder.WriteLine("{");
        sourceBuilder.Indent++;
        foreach (var member in emoteManagerInfo.EmoteSpecMembers)
        {
            sourceBuilder.WriteLine($"public {EmoteInterfaceQualifiedName} {member} {{ get; init; }}");
        }
        sourceBuilder.Indent--;
        sourceBuilder.WriteLine("}");
        sourceBuilder.Indent--;
        sourceBuilder.WriteLine("}");
        
        return textWriter.ToString();
    }

    private static EmoteManagerInfo? GetNeededManagerInfo(GeneratorAttributeSyntaxContext ctx, CancellationToken token)
    {
        if (ctx.TargetSymbol is not INamedTypeSymbol managerSymbol)
        {
            return null;
        }

        token.ThrowIfCancellationRequested();

        var attributeData = managerSymbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == AttributeName);

        if (attributeData?.ConstructorArguments[0].Value is not INamedTypeSymbol specSymbol)
            return null;

        var specMembers = specSymbol.GetMembers();
        var members = new List<string>(specMembers.Length);

        foreach (var member in specMembers)
        {
            if(member is not IPropertySymbol property)
                continue;
            
            if (property.DeclaredAccessibility == Accessibility.Public &&
                property.Type.ToDisplayString() == EmoteSpecificationInterfaceDisplayName)
            {
                members.Add(property.Name);
            }
        }

        // not sure what the correct ToString is
        var nameSpace = managerSymbol.ContainingNamespace.IsGlobalNamespace
            ? string.Empty
            : managerSymbol.ContainingNamespace.ToString();
        var managerClassname = managerSymbol.Name;
        var emoteSpecQualifiedName = specSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var emoteModelClassNameToGenerate = $"{specSymbol.Name}_Model";

        return new EmoteManagerInfo(
            nameSpace,
            managerClassname,
            emoteSpecQualifiedName,
            emoteModelClassNameToGenerate,
            new EquatableArray<string>(members.ToArray()));
    }

    private readonly record struct EmoteManagerInfo(
        string Namespace,
        string EmoteManagerClassName,
        string EmoteSpecQualifiedName,
        string EmoteModelClassNameToGenerate,
        EquatableArray<string> EmoteSpecMembers)
    {
        public readonly string Namespace = Namespace;
        public readonly string EmoteManagerClassName = EmoteManagerClassName;
        public readonly string EmoteSpecQualifiedName = EmoteSpecQualifiedName;
        public readonly string EmoteModelClassNameToGenerate = EmoteModelClassNameToGenerate;
        public readonly EquatableArray<string> EmoteSpecMembers = EmoteSpecMembers;
    }
}