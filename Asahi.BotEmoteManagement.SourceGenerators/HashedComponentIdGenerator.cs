using System.CodeDom.Compiler;
using System.IO.Hashing;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

// not related to BotEmoteManagement but im too lazy to create a new class or rename or whatever
namespace Asahi.BotEmoteManagement.SourceGenerators;

[Generator]
public class HashedComponentIdGenerator : IIncrementalGenerator
{
    private const string BotEmoteManagementNamespace = "Asahi.BotEmoteManagement";
    private const string AttributeName = $"{BotEmoteManagementNamespace}.GenerateHashedIdsAttribute";
    private const string GeneratedCodeAttribute =
        $"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Asahi.BotEmoteManagement.SourceGenerators.{nameof(HashedComponentIdGenerator)}\", \"0.0.0.0\")]";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var declarations = context.SyntaxProvider
            .ForAttributeWithMetadataName(AttributeName,
                predicate: static (node, _) =>
                    node is VariableDeclaratorSyntax vdrs && 
                    vdrs.Parent is VariableDeclarationSyntax vdns && 
                    vdns.Parent is FieldDeclarationSyntax fds && 
                    fds.Modifiers.Any(SyntaxKind.ConstKeyword),
                transform: static (ctx, token) => GetNeededManagerInfo(ctx, token))
            .Where(static m => m is not null)
            .Select(static (m, _) => m!.Value);

        context.RegisterSourceOutput(declarations, Execute);
    }

    private static void Execute(SourceProductionContext context, HashedComponentIdInfo hashedComponentIdInfo)
    {
        var result = GenerateCode(hashedComponentIdInfo);

        // sucks ass but caching demands
        context.AddSource(
            $"{hashedComponentIdInfo.Namespace}.{hashedComponentIdInfo.ClassName}.{hashedComponentIdInfo.FieldName}.g.cs",
            SourceText.From(result, Encoding.UTF8));
    }

    private static string GenerateCode(HashedComponentIdInfo hashedComponentIdInfo)
    {
        using var textWriter = new StringWriter();
        using var sourceBuilder = new IndentedTextWriter(textWriter);
        
        var hashedValue = Base2048Converter.Encode(Crc32.Hash(Encoding.UTF8.GetBytes(hashedComponentIdInfo.ConstantValue)));
        
        sourceBuilder.WriteLine("// <auto-generated/>");
        sourceBuilder.WriteLine($"namespace {hashedComponentIdInfo.Namespace};");
        sourceBuilder.WriteLine();
        // hardcoding `class` here isn't good, but this won't be used on anything except a certain class, so it doesn't matter
        sourceBuilder.WriteLine($"partial class {hashedComponentIdInfo.ClassName}");
        sourceBuilder.WriteLine("{");
        sourceBuilder.Indent++;
        // hardcoding `public` here isn't good (again), but the above reason applies here also so
        sourceBuilder.WriteLine(GeneratedCodeAttribute);
        sourceBuilder.WriteLine($"public const string {hashedComponentIdInfo.FieldName}Hashed = \"{hashedValue}\";");
        sourceBuilder.Indent--;
        sourceBuilder.WriteLine("}");
        
        return textWriter.ToString();
    }

    private static HashedComponentIdInfo? GetNeededManagerInfo(GeneratorAttributeSyntaxContext ctx,
        CancellationToken token)
    {
        if (ctx.TargetSymbol is not IFieldSymbol fieldSymbol)
        {
            return null;
        }

        token.ThrowIfCancellationRequested();

        // not sure what the correct ToString is
        var nameSpace = fieldSymbol.ContainingNamespace.IsGlobalNamespace
            ? string.Empty
            : fieldSymbol.ContainingNamespace.ToString();
        var className = fieldSymbol.ContainingType.Name;
        var constantValue = fieldSymbol.ConstantValue;

        if (constantValue is not string stringConstant)
            return null;

        return new HashedComponentIdInfo(
            nameSpace,
            className,
            fieldSymbol.Name,
            stringConstant);
    }

    private readonly record struct HashedComponentIdInfo(
        string Namespace,
        string ClassName,
        string FieldName,
        string ConstantValue)
    {
        public readonly string Namespace = Namespace;
        public readonly string ClassName = ClassName;
        public readonly string FieldName = FieldName;
        public readonly string ConstantValue = ConstantValue;
    }
}