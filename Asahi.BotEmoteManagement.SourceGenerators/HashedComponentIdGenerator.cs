using System.CodeDom.Compiler;
using System.IO.Hashing;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

// not related to BotEmoteManagement but im too lazy to create a new class or rename or whatever
namespace Asahi.BotEmoteManagement.SourceGenerators;

[Generator]
public class HashedComponentIdGenerator : IIncrementalGenerator
{
    private const string BotEmoteManagementNamespace = "Asahi.BotEmoteManagement";
    private const string ClassAttributeName = $"{BotEmoteManagementNamespace}.GenerateHashedIdsAttribute";
    private const string IdAttributeName = $"{BotEmoteManagementNamespace}.HashedIdAttribute";

    private const string GeneratedCodeAttribute =
        $"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Asahi.BotEmoteManagement.SourceGenerators.{nameof(HashedComponentIdGenerator)}\", \"0.0.0.0\")]";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var declarations = context.SyntaxProvider
            .ForAttributeWithMetadataName(ClassAttributeName,
                predicate: static (node, _) =>
                    node is ClassDeclarationSyntax syntax && syntax.Modifiers.Any(SyntaxKind.PartialKeyword),
                transform: static (ctx, token) => GetNeededManagerInfo(ctx, token))
            .Where(static m => m is not null)
            .Select(static (m, _) => m!.Value);

        context.RegisterSourceOutput(declarations, Execute);
    }

    private static void Execute(SourceProductionContext context, HashedComponentIdClassInfo hashedComponentIdClassInfo)
    {
        var result = GenerateCode(hashedComponentIdClassInfo);

        var sb = new StringBuilder();
        sb.Append(nameof(HashedComponentIdGenerator));
        sb.Append('.');
        sb.Append(hashedComponentIdClassInfo.Namespace);
        sb.Append('.');
        for (int i = hashedComponentIdClassInfo.ReversedClassHierarchy.Count - 1; i >= 0; i--)
        {
            sb.Append(hashedComponentIdClassInfo.ReversedClassHierarchy[i]);
            if (i != 0)
                sb.Append('.');
        }

        sb.Append(".g.cs");

        context.AddSource(sb.ToString(), SourceText.From(result, Encoding.UTF8));
    }

    private static string GenerateCode(HashedComponentIdClassInfo hashedComponentIdClassInfo)
    {
        using var textWriter = new StringWriter();
        using var sourceBuilder = new IndentedTextWriter(textWriter);

        sourceBuilder.WriteLine("// <auto-generated/>");
        sourceBuilder.WriteLine($"namespace {hashedComponentIdClassInfo.Namespace};");
        sourceBuilder.WriteLine();
        var classPrefix = new StringBuilder();
        classPrefix.Append(hashedComponentIdClassInfo.Namespace);
        classPrefix.Append('.');
        for (int i = hashedComponentIdClassInfo.ReversedClassHierarchy.Count - 1; i >= 0; i--)
        {
            var className = hashedComponentIdClassInfo.ReversedClassHierarchy[i];

            if (i == 0)
            {
                sourceBuilder.WriteLine(GeneratedCodeAttribute);
            }

            // hardcoding `class` here isn't good, but this won't be used on anything except a certain class, so it doesn't matter
            sourceBuilder.WriteLine($"partial class {className}");
            sourceBuilder.WriteLine("{");
            sourceBuilder.Indent++;

            classPrefix.Append(hashedComponentIdClassInfo.ReversedClassHierarchy[i]);
            if (i != 0)
                classPrefix.Append('.');
        }

        bool firstEntry = true;
        foreach (var attribute in hashedComponentIdClassInfo.HashedIdAttributes)
        {
            var unhashedValue = attribute.UnhashedValue ?? $"{classPrefix}.{attribute.ConstantFieldName}";

            var hashedValue = Base2048Converter.Encode(Crc32.Hash(Encoding.UTF8.GetBytes(unhashedValue))) + ':';

            if (firstEntry)
            {
                firstEntry = false;
            }
            else
            {
                sourceBuilder.WriteLine();
            }

            sourceBuilder.WriteLine($"/// <summary>Base2048-encoded CRC32 hash of \"{unhashedValue}\".</summary>");
            sourceBuilder.WriteLine(
                $"public const string {attribute.ConstantFieldName} = \"{hashedValue}\";");
        }

        for (int i = hashedComponentIdClassInfo.ReversedClassHierarchy.Count - 1; i >= 0; i--)
        {
            sourceBuilder.Indent--;
            sourceBuilder.WriteLine("}");
        }

        return textWriter.ToString();
    }

    private static HashedComponentIdClassInfo? GetNeededManagerInfo(GeneratorAttributeSyntaxContext ctx,
        CancellationToken token)
    {
        if (ctx.TargetSymbol is not INamedTypeSymbol classSymbol)
        {
            return null;
        }

        token.ThrowIfCancellationRequested();

        var attributes = classSymbol.GetAttributes();

        var hashedIdAttributes = new List<HashedIdAttributeInfo>(attributes.Length);
        foreach (var attribute in attributes.Where(a => a.AttributeClass?.ToDisplayString() == IdAttributeName))
        {
            if (attribute.ConstructorArguments[0].Value is not string constantFieldName)
                continue;

            var unhashedValue = attribute.NamedArguments
                .FirstOrDefault(x => x is
                {
                    Key: "UnhashedValue",
                    Value.IsNull: false,
                    Value.Value: string
                }).Value.Value as string;
            ;

            hashedIdAttributes.Add(new HashedIdAttributeInfo(constantFieldName, unhashedValue));
        }

        // not sure what the correct ToString is
        var nameSpace = classSymbol.ContainingNamespace.IsGlobalNamespace
            ? string.Empty
            : classSymbol.ContainingNamespace.ToString();

        var classHierarchy = new List<string>();
        var currentType = classSymbol;
        while (currentType != null)
        {
            classHierarchy.Add(currentType.Name);
            currentType = currentType.ContainingType;
        }

        return new HashedComponentIdClassInfo(
            nameSpace,
            new EquatableArray<string>(classHierarchy.ToArray()),
            new EquatableArray<HashedIdAttributeInfo>(hashedIdAttributes.ToArray()));
    }

    private readonly record struct HashedComponentIdClassInfo(
        string Namespace,
        EquatableArray<string> ReversedClassHierarchy,
        EquatableArray<HashedIdAttributeInfo> HashedIdAttributes);

    // the name is slightly confusing, it means information about the attribute "HashedIdAttribute"
    // not that its information about a hashed ID
    private readonly record struct HashedIdAttributeInfo(string ConstantFieldName, string? UnhashedValue = null);
}